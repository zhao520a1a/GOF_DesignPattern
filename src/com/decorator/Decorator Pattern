装饰者模式：在不改变原类文件和不使用继承的情况下，动态地扩展一个对象的功能；
			它是通过创建一个包装对象，来装饰包裹真实的对象；
			
装饰者模式角色定义：
抽象构件角色：如例子中的Girl类；
具体构件角色：如例子中的AmericanGirl,ChineseGirl类;
抽象装饰者角色： 如例子中的GirlDecorator类;
具体装饰者角色：如例子中的Art,Dance,Sing类;一般要用组合的方式；

设计思路：
	抽象构件中定义了构件需呀装饰的功能；
	具体构件继承了抽象构件，有其特有的方法属性；
	抽象装饰者类继承了抽象构件，它提供了抽象的装饰方法；
	具体装饰者继承了抽象装饰者，定义了具体的装饰方法，通过和抽象构件组合的方式来实际装饰具体构件；

注意：一般了来说具体装饰者是和抽象构件（因为其中已有的构件需要装饰的功能）进行通信的，进而通过虚方法调用来装饰具体构件的功能，
              最后使用被装饰过的装饰者对象，并且装饰者对象之间还也可以互相装饰，这样就可创造出很多组合；

应用场景：
1.想透明并且动态地给对象增加新的职责时；
2.给对象增加在未来可能增加或减少的职责；
3.用继承方式扩展功能不太现实的时；

优点：可以提供比继承更多的灵活性；
                可以通过使用不同的装饰类及它们之间的排列组合，创造出很多不同行为的组合；
缺点:比继承更复杂；
           会出现许多小类，若过度使用程序变得更复杂；
     它是针对抽象组件类型的编程，但是针对具体组件编程时，就要重新思考应用架构以及装饰者是否合适，
     当然也可以改变component接口，增加新的公开行为，实现“半透明”的装饰者模式（如范中例那样:继承+装饰）；
     要根据实际情况做出最佳选择；